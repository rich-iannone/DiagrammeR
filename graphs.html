<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="DiagrammeR, an R package that allows you to create flowcharts, diagrams, and graphs with Markdown-like text.">
        <meta name="keywords" content="R, JavaScript, graphviz, mermaid">
        <meta name="author" content="Richard Iannone and DiagrammeR contributors">

        <link rel="apple-touch-icon" sizes="57x57" href="icon/apple-icon-57x57.png">
        <link rel="apple-touch-icon" sizes="60x60" href="icon/apple-icon-60x60.png">
        <link rel="apple-touch-icon" sizes="72x72" href="icon/apple-icon-72x72.png">
        <link rel="apple-touch-icon" sizes="76x76" href="icon/apple-icon-76x76.png">
        <link rel="apple-touch-icon" sizes="114x114" href="icon/apple-icon-114x114.png">
        <link rel="apple-touch-icon" sizes="120x120" href="icon/apple-icon-120x120.png">
        <link rel="apple-touch-icon" sizes="144x144" href="icon/apple-icon-144x144.png">
        <link rel="apple-touch-icon" sizes="152x152" href="icon/apple-icon-152x152.png">
        <link rel="apple-touch-icon" sizes="180x180" href="icon/apple-icon-180x180.png">
        <link rel="icon" type="image/png" sizes="192x192"  href="icon/android-icon-192x192.png">
        <link rel="icon" type="image/png" sizes="32x32" href="icon/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="96x96" href="icon/favicon-96x96.png">
        <link rel="icon" type="image/png" sizes="16x16" href="icon/favicon-16x16.png">
        <link rel="manifest" href="icon/manifest.json">
        <meta name="msapplication-TileColor" content="#ffffff">
        <meta name="msapplication-TileImage" content="icon/ms-icon-144x144.png">
        <meta name="theme-color" content="#ffffff">

        <title>
        DiagrammeR - Documentation
        </title>

        <link href="css/bootstrap.min.css" rel="stylesheet">
        <link href="css/docs.min.css" rel="stylesheet">

        <script src="js/ie-emulation-modes-warning.js"></script>

    </head>

<body>
    <a id="skippy" class="sr-only sr-only-focusable" href="#content"><div class="container"><span class="skiplink-text">Skip to main content</span></div></a>

    <!-- Docs master nav -->
    <header class="navbar navbar-static-top bs-docs-nav" id="top" role="banner">
        <div class="container">
            <div class="navbar-header">
                <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a href="index.html" class="navbar-brand">DiagrammeR</a>
            </div>
            <nav class="collapse navbar-collapse bs-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li>
                      <a href="docs.html">Getting started</a>
                    </li>
                    <li>
                      <a href="io.html">I/O</a>
                    </li>
                    <li>
                      <a href="graphviz.html">Graphviz</a>
                    </li>
                    <li>
                      <a href="mermaid.html">Mermaid</a>
                    </li>
                    <li class="active">
                      <a href="graphs.html">Building Graphs</a>
                    </li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://github.com/rich-iannone/DiagrammeR">GitHub</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <!-- Docs page layout -->
    <div class="bs-docs-header" id="content">
        <div class="container">
        <h1>DiagrammeR Docs</h1>
        <p>Get an overview of DiagrammeR, learn the syntax, check out some examples.</p>
        </div>
    </div>
    <div class="container bs-docs-container">
        <div class="row">
            <div class="col-md-9" role="main">
                <div class="bs-docs-section">
                    <h1 id="building-graphs" class="page-header">Building Graphs</h1>
                    <p class="lead"><strong>DiagrammeR</strong> has a nice set of functions for building graphs. You can continually build the graph object, modify its attributes, get information from it, and render a graph diagram. </p>
                    <h2 id="the-graph-functions">The Graph Functions</h2>
                    <p>A collection of graph functions is available for creating and manipulating graphs (specifically, graph objects). They allow you to generate node and edge data frames (collections of nodes or edges along with their attributes), perform scaling of attribute values with data values, traverse the graph and obtain specific information from nodes and edges (and quite a bit more).</p>
                    <div>
                        <img src="img/graph-functions/graph_functions_1.png" class="img-responsive center-block">
                        <img src="img/graph-functions/graph_functions_2.png" class="img-responsive center-block">
                        <img src="img/graph-functions/graph_functions_3.png" class="img-responsive center-block">
                        <img src="img/graph-functions/graph_functions_4.png" class="img-responsive center-block">
                        <img src="img/graph-functions/graph_functions_5.png" class="img-responsive center-block">
                        <img src="img/graph-functions/graph_functions_6.png" class="img-responsive center-block">
                        <img src="img/graph-functions/graph_functions_7.png" class="img-responsive center-block">
                        <img src="img/graph-functions/graph_functions_8.png" class="img-responsive center-block">
                    </div>
                    <div>
                        <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                    </div>
                    <h2 id="the-graph-object">The Graph Object</h2>
                    <p>The <strong>DiagrammeR</strong> graph object, created by using the function <code>create_graph()</code>, holds information on a graph's nodes, edges, default attributes, and rendering code. Creating a graph object can be as simple as using <code>create_graph()</code>, however, that will be an empty graph and you'll want to populate it.</p>
                    <p>The <strong>DiagrammeR</strong> graph object holds buckets of data that reflect the current state of the graph. The graph can be inspected, nodes and edges can be added, edited, or removed, and, a visualization of the graph or export of its data can be made at any point. The different facets of what make up the graph object can be visualized as follows.</p>
                    <p>Essentially, the elements that make up a graph are tightly coupled inside the graph object. The myriad functions developed for working with the graph object:</p>
                    <ul>
                        <li>preserve the integrity of the data</li>
                        <li>allow for graph migrations from state to state</li>
                        <li>provide an easy-to-use interface for working with graph data</li>
                    </ul>
                    <h2 id="specialized-data-frames">Specialized Data Frames</h2>
                    <p>Getting data into a graph object is made easier through the use of specialized data frames for that contain either node data and attributes and those data frames that contain edge data and edge attributes. These data frames are especially helpful when moving data from external sources into a graph. This is because these data frames are permitted to have columns of arbitrary data alongside columns named for node or edge attributes. Having columns of data available on a per-node or per-edge basis allows for easy numerical scaling of attributes and thus a highly visual means to differentiate nodes and edges by size, color, shape, opacity, length, and more.</p>
                </div>
                <div class="bs-docs-section">
                    <h1 id="graph-functions" class="page-header">Graph Functions</h1>
                    <p class="lead">If you're planning on creating graph diagrams and also making use of external datasets, you can make use of a set of <strong>DiagrammeR</strong> functions that work well with data frames. Data and attributes can be collected in this way, provided to a graph object, and then inspected, manipulated, and displayed.</p>
                    <h2 id="node-edge-data-frames">Node/Edge Data Frames</h2>
                    <p>These functions are used to create specialized data frames. One type is for nodes, the other for edges. The functions are useful because one can add field data to these data frames and selectively add and scale attributes. Some of the functions for creating node and edge data frames include:</p>
                    <ul>
                            <li><code>create_nodes()</code> <em>Create a data frame with nodes and their attributes</em></li>
                            <li><code>create_edges()</code> <em>Create a data frame with edges and their attributes</em></li>
                            <li><code>combine_nodes()</code> <em>Combine multiple node data frames into a single node data frame</em></li>
                            <li><code>combine_edges()</code> <em>Combine multiple edge data frames into a single edge data frame</em></li>
                    </ul>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/create_nodes_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/combine_nodes_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/create_edges_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/combine_edges_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                    <p>Both types of data frames are parsed and those column names that match attributes for either nodes (in the node data frame) or edges (in the edge data frame) will be used to provide attribute values on a per-node or per-edge basis. Columns with names that don't match reserved attribute names are disregarded and, because of this, you can include columns with useful data for analysis. When creating a data frame for nodes, it's important to have at least one column named <code>nodes</code>. That's where unique values for the node ID should reside. As for other attribute columns, here are all of the node attribute names and the types of values to supply:</p>
                    <ul>
                            <li><code>color</code> &mdash; provide an <strong>X11</strong> or hexadecimal color (append 2 digits to hex for alpha)</li>
                            <li><code>distortion</code> &mdash; the node distortion for any <code>shape = polygon</code></li>
                            <li><code>fillcolor</code> &mdash; provide an <strong>X11</strong> or hexadecimal color (append 2 digits to hex for alpha)</li>
                            <li><code>fixedsize</code> &mdash; <code>true</code> or <code>false</code></li>
                            <li><code>fontcolor</code> &mdash; provide an <strong>X11</strong> or hexadecimal color (append 2 digits to hex for alpha)</li>
                            <li><code>fontname</code> &mdash; the name of the font</li>
                            <li><code>fontsize</code> &mdash; the size of the font for the node label</li>
                            <li><code>height</code> &mdash; the height of the node</li>
                            <li><code>label</code> &mdash; the node label text that replaces the default text (which is the node ID)</li>
                            <li><code>penwidth</code> &mdash; the thickness of the stroke for the shape</li>
                            <li><code>peripheries</code> &mdash; the number of peripheries (essentially, additional shape outlines)</li>
                            <li><code>shape</code> &mdash; the node shape (e.g., <code>ellipse</code>, <code>polygon</code>, <code>circle</code>, etc.)</li>
                            <li><code>sides</code> &mdash; if <code>shape = polygon</code>, the number of sides can be provided here</li>
                            <li><code>style</code> &mdash; usually given the value filled if you'd like to fill a node with a color</li>
                            <li><code>tooltip</code> &mdash; provide text here for an unstyled browser tooltip</li>
                            <li><code>width</code> &mdash; the width of the node</li>
                            <li><code>x</code> &mdash; the x position of the node (requires graph attr <code>layout = neato</code> to use)</li>
                            <li><code>y</code> &mdash; the y position of the node (requires graph attr <code>layout = neato</code> to use)</li>
                        </ul>
                    <p>While you can use the <code>data.frame()</code> function to make a node data frame, it is likely better to use the provided <code>create_nodes()</code> function. It's similar in principle to the base <strong>R</strong> <code>data.frame()</code> function except that it adds in the following conveniences for graph diagram work:
                        <ul>
                            <li>single values are repeated for n number of nodes supplied</li>
                            <li>selective setting of attributes (e.g., giving attr values for 3 of 10 nodes, allowing non-set nodes to use defaults or globally set attr values)</li>
                            <li>supplying overlong vectors for attributes will result in trimming down to the number of nodes</li>
                            <li>setting <code>label = FALSE</code> will conveniently result in a non-labeled node</li>
                        </ul>
                    <p>There may be occasion to combine several of these data frames into a single node data frame. This can be done with the <code>combine_nodes()</code> function (which works much like <code>rbind()</code> except that it accepts data frames with columns differing in number, names, and ordering).</p>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint">###
# Create two data frames for nodes
# Singly supplied attribute values are repeated down
###

library(DiagrammeR)

# Create a node data frame
nodes_1 &lt;-
  create_nodes(nodes = c("a", "b", "c", "d"),
               label = FALSE,
               type = "lower",
               style = "filled",
               color = "aqua",
               shape = c("circle", "circle",
                         "rectangle", "rectangle"),
               data = c(3.5, 2.6, 9.4, 2.7))

nodes_1
#>   nodes label  type  style color     shape data
#> 1     a       lower filled  aqua    circle  3.5
#> 2     b       lower filled  aqua    circle  2.6
#> 3     c       lower filled  aqua rectangle  9.4
#> 4     d       lower filled  aqua rectangle  2.7

# Create another node data frame
nodes_2 &lt;-
  create_nodes(nodes = c("e", "f", "g", "h"),
               label = FALSE,
               type = "upper",
               style = "filled",
               color = "red",
               shape = "triangle",
               data = c(0.5, 3.9, 3.7, 8.2))

nodes_2
#>   nodes label  type  style color    shape data
#> 1     e       upper filled   red triangle  0.5
#> 2     f       upper filled   red triangle  3.9
#> 3     g       upper filled   red triangle  3.7
#> 4     h       upper filled   red triangle  8.1

###
# Combine two data frames for nodes
###

# Combine node data frames with 'combine_nodes'
all_nodes &lt;- combine_nodes(nodes_1, nodes_2)

all_nodes
#>   nodes label  type  style color     shape data
#> 1     a       lower filled  aqua    circle  3.5
#> 2     b       lower filled  aqua    circle  2.6
#> 3     c       lower filled  aqua rectangle  9.4
#> 4     d       lower filled  aqua rectangle  2.7
#> 5     e       upper filled   red  triangle  0.5
#> 6     f       upper filled   red  triangle  3.9
#> 7     g       upper filled   red  triangle  3.7
#> 8     h       upper filled   red  triangle  8.2
</code></pre>
                        </div>
                    </div>
                    <p>When making a data frame for edge data, there are two columns that need to be present: one for the outgoing node edge (<code>from</code>), and, another for the incoming node edge (<code>to</code>). Each of the two columns should contain node IDs. As for the node data frame, attributes can be provided for edges. The following edge attributes can be used:</p>
                        <ul>
                            <li><code>arrowhead</code> &mdash; the arrow style at the head end (e.g, <code>normal</code>, <code>dot</code>)</li>
                            <li><code>arrowsize</code> &mdash; the scaling factor for the arrowhead and arrowtail</li>
                            <li><code>arrowtail</code> &mdash; the arrow style at the tail end (e.g, <code>normal</code>, <code>dot</code>)</li>
                            <li><code>color</code> &mdash; the stroke color; an <strong>X11</strong> color or a hex code (add 2 digits for alpha)</li>
                            <li><code>dir</code> &mdash; the direction; either <code>forward</code>, <code>back</code>, <code>both</code>, or <code>none</code></li>
                            <li><code>fontcolor</code> &mdash; choose an <strong>X11</strong> color or provide a hex code (append 2 digits for alpha)</li>
                            <li><code>fontname</code> &mdash; the name of the font</li>
                            <li><code>fontsize</code> &mdash; the size of the font for the node label</li>
                            <li><code>headport</code> &mdash; a cardinal direction for where the arrowhead meets the node</li>
                            <li><code>label</code> &mdash; label text for the line between nodes</li>
                            <li><code>minlen</code> &mdash; minimum rank distance between head and tail</li>
                            <li><code>penwidth</code> &mdash; the thickness of the stroke for the arrow</li>
                            <li><code>tailport</code> &mdash; a cardinal direction for where the tail is emitted from the node</li>
                            <li><code>tooltip</code> &mdash; provide text here for an edge tooltip</li>
                        </ul>
                    <p>Use the <code>create_edges()</code> function to create data frames for edges and their attributes. Data frames for edge definitions and their associated attributes can then be safely combined using the <code>combine_edges()</code> function.</p>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint">###
# Create two data frames for edges
# Singly supplied attribute values are repeated down
###

library(DiagrammeR)

# Create an edge data frame
edges_1 &lt;-
  create_edges(from = c("a", "a", "b", "c"),
               to = c("b", "d", "d", "a"),
               rel = "requires",
               color = "green",
               data = c(2.7, 8.9, 2.6, 0.6))

edges_1
#>   from to rel color data
#> 1    a  b     requires green  2.7
#> 2    a  d     requires green  8.9
#> 3    b  d     requires green  2.6
#> 4    c  a     requires green  0.6

# Create another edge data frame
edges_2 &lt;-
  create_edges(from = c("e", "g", "h", "h"),
               to = c("g", "h", "f", "e"),
               rel = "receives",
               arrowhead = "dot",
               color = "red")

edges_2
#>   from to rel arrowhead color
#> 1    e  g     receives       dot   red
#> 2    g  h     receives       dot   red
#> 3    h  f     receives       dot   red
#> 4    h  e     receives       dot   red

###
# Combine two data frames for edges
###

# Combine edge data frames with 'combine_edges'
all_edges &lt;- combine_edges(edges_1, edges_2)

all_edges
#>   from to rel color data arrowhead
#> 1    a  b     requires green  2.7
#> 2    a  d     requires green  8.9
#> 3    b  d     requires green  2.6
#> 4    c  a     requires green  0.6
#> 5    e  g     receives   red            dot
#> 6    g  h     receives   red            dot
#> 7    h  f     receives   red            dot
#> 8    h  e     receives   red            dot
</code></pre>
                        </div>
                    </div>
                    <h2 id="create-render-graph">Create and Render Graph</h2>
                    <p>Eventually, you'll want to make a graph and then see that graph. There are 2 functions that make graph creation and viewing possible:</p>
                    <ul>
                            <li><code>create_graph()</code> <em>Create a graph object using data frames representative of nodes and edges</em></li>
                            <li><code>render_graph()</code> <em>Render the graph or output in various formats</em></li>
                    </ul>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/create_graph_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/render_graph_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                    <p>With the <code>create_graph()</code> function, it's possible to generate a graph diagram object without interacting directly with <strong>DOT</strong> code. The function has the following options:</p>
<div>
<pre><code>create_graph(
    nodes_df,     # provide the name of the data frame with node info
    edges_df,     # provide the name of the data frame with edge info
    graph_attrs,  # provide a vector of `graph` attributes
    node_attrs,   # provide a vector of `node` attributes as defaults
    edge_attrs,   # provide a vector of `edge` attributes as defaults
    directed      # is the graph to be directed or undirected? Choose
                  # `TRUE` or `FALSE`
    )
</code></pre>
                    </div>
                    <p>The <code>create_graph()</code> function returns a <code>dgr_graph</code> object, which can be used by additional processing functions.</p>
                    <p>The <code>render_graph()</code> function allows for both visualizing the graph object and creating output files:</p>
                    <div>
<pre><code>render_graph(
    graph,   # a 'dgr_graph' object, created using the `create_graph()` function
    output,  # a string specifying the output type; `graph` (the default) renders
             # the graph and `DOT` outputs DOT code for the graph
    width,   # optionally set a width in pixels
    height   # optionally set a height in pixels
    )
</code></pre>
                    </div>
                    <p>For a first, simple example we can create an empty graph by using the <code>create_graph()</code> function and supplying no arguments. This may be useful for initializing a graph object and then adding nodes and edges using functions such as <code>add_node()</code> and <code>add_edge()</code>.</p>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint">###
# Create an empty graph
###

library(DiagrammeR)

# Create the graph object
graph &lt;- create_graph()

graph
#> $nodes_df
#> NULL
#>
#> $edges_df
#> NULL
#>
#> $graph_attrs
#> NULL
#>
#> $node_attrs
#> NULL
#>
#> $edge_attrs
#> NULL
#>
#> $directed
#> [1] TRUE
#>
#> $dot_code
#> [1] "digraph {\n\n}"
#>
#> attr(,"class")
#> [1] "dgr_graph"</code></pre>
                        </div>
                    </div>
<p>This next example will include just nodes in a graph object, and, quite often you'll want to have node or edge attributes that should apply to all nodes and edges in the graph. For that there's no need to create columns for those shared attributes (where you might repeat attribute values through all rows of a node or edge data frame). Instead, supply vectors of attribute statements for the <code>node_attrs</code> or <code>edge_attrs</code> arguments in the <code>create_graph()</code> function. In this example, a graph containing just nodes will be created.</p>
<div class="bs-example">
                        <img src="img/graph-functions/nodes_only_example.png" class="img-responsive center-block">
                    </div>
<div class="highlight">
                        <div>
                            <pre><code class="prettyprint">###
# Create a graph with nodes but no edges
###

library(DiagrammeR)

# Create a node data frame
nodes &lt;-
  create_nodes(nodes = c("a", "b", "c", "d"),
               label = FALSE,
               type = "lower",
               style = "filled",
               color = "aqua",
               shape = c("circle", "circle",
                         "rectangle", "rectangle"),
               data = c(3.5, 2.6, 9.4, 2.7))

graph &lt;- create_graph(nodes_df = nodes)

graph
#> $nodes_df
#>   nodes label  type  style color     shape data
#> 1     a       lower filled  aqua    circle  3.5
#> 2     b       lower filled  aqua    circle  2.6
#> 3     c       lower filled  aqua rectangle  9.4
#> 4     d       lower filled  aqua rectangle  2.7
#>
#> $edges_df
#> NULL
#>
#> $graph_attrs
#> NULL
#>
#> $node_attrs
#> NULL
#>
#> $edge_attrs
#> NULL
#>
#> $directed
#> [1] TRUE
#>
#> $dot_code
#> [1] "digraph {\n\n  'a' [label = ' ', style = 'filled',...
#>
#> attr(,"class")
#> [1] "dgr_graph"

# View the graph in the RStudio Viewer
render_graph(graph)</code></pre>
                        </div>
                    </div>
<p>This next example will include both nodes and edges contained within a graph object. In this case, values for the <code>type</code> and <code>rel</code> attributes for nodes and edges, respectively, were provided. Adding values for those attributes is optional but will be important for any data modelling work.</p>
<div class="bs-example">
                        <img src="img/graph-functions/nodes_edges_example.png" class="img-responsive center-block">
                    </div>
<div class="highlight">
                        <div>
                            <pre><code class="prettyprint">###
# Create a graph with both nodes and edges
# defined, and, add some default attributes
# for nodes and edges
###

library(DiagrammeR)

# Create a node data frame
nodes &lt;-
  create_nodes(nodes = c("a", "b", "c", "d"),
               label = FALSE,
               type = "lower",
               style = "filled",
               color = "aqua",
               shape = c("circle", "circle",
                         "rectangle", "rectangle"),
               data = c(3.5, 2.6, 9.4, 2.7))

edges &lt;-
  create_edges(from = c("a", "b", "c"),
               to = c("d", "c", "a"),
               rel = "leading_to")


graph &lt;-
  create_graph(nodes_df = nodes,
               edges_df = edges,
               node_attrs = "fontname = Helvetica",
               edge_attrs = c("color = blue",
                              "arrowsize = 2"))

graph
#> $nodes_df
#>   nodes label  type  style color     shape data
#> 1     a       lower filled  aqua    circle  3.5
#> 2     b       lower filled  aqua    circle  2.6
#> 3     c       lower filled  aqua rectangle  9.4
#> 4     d       lower filled  aqua rectangle  2.7
#>
#> $edges_df
#>   from to rel
#> 1    a  d   leading_to
#> 2    b  c   leading_to
#> 3    c  a   leading_to
#>
#> $graph_attrs
#> [1] NULL
#>
#> $node_attrs
#> [1] "fontname = Helvetica"
#>
#> $edge_attrs
#> [1] "color = blue"  "arrowsize = 2"
#>
#> $directed
#> [1] TRUE
#>
#> $dot_code
#> [1] "digraph {\n\ngraph [rankdir = LR]\n\nnode [fontnam...
#>
#> attr(,"class")
#> [1] "dgr_graph"

# View the graph in the RStudio Viewer
render_graph(graph)</code></pre>
                        </div>
                    </div>
                    <p>The graph attributes can be set in a similar manner by supplying a vector to the <code>graph_attrs</code> argument. In the next rendering, the layout engine is set to <code>twopi</code> and this provides for a radically different layout of nodes than the standard method. Also, because we are using sampling in this example, setting a seed with <code>set.seed()</code> will make the example reproducible.</p>
                    <div class="bs-example">
                        <img src="img/graph-functions/LETTERS_example.png" class="img-responsive center-block">
                    </div>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint">###
# Create a graph
###

library(DiagrammeR)

set.seed(23)

# Create a node data frame
nodes &lt;-
  create_nodes(nodes = LETTERS,
               type = "letter",
               shape = sample(c("circle", "rectangle"),
                              length(LETTERS),
                              replace = TRUE),
               fillcolor = sample(c("aqua", "gray80",
                                    "pink", "lightgreen",
                                    "azure", "yellow"),
                                  length(LETTERS),
                                  replace = TRUE))

edges &lt;-
  create_edges(from = sample(LETTERS, replace = TRUE),
               to = sample(LETTERS, replace = TRUE),
               rel = "letter_to_letter")


graph &lt;-
  create_graph(nodes_df = nodes,
               edges_df = edges,
               graph_attrs = "layout = neato",
               node_attrs = c("fontname = Helvetica",
                              "style = filled"),
               edge_attrs = c("color = gray20",
                              "arrowsize = 0.5"))

# View the graph in the RStudio Viewer
render_graph(graph)</code></pre>
                        </div>
                    </div>
                    <p>With packages such as <strong>magrittr</strong> or <strong>pipeR</strong>, one can conveniently pipe output from <code>create_graph()</code> to <code>render_graph()</code>. The <strong>magrittr</strong> package provides a forward pipe with the <code>%>%</code> operator. With <strong>pipeR</strong>, use <code>%>>%</code> instead.</p>
                    <p>If you'd like to return the <strong>Graphviz</strong> <strong>DOT</strong> code (to, perhaps, share it or use it directly with the <strong>Graphviz</strong> command-line utility), just use <code>output = "DOT"</code> in the <code>render_graph()</code> function. Here's a simple example:</p>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint">###
# Create node and edge data frames for graph
###

library(DiagrammeR)
library(pipeR)

# Create a node data frame
nodes &lt;-
  create_nodes(nodes = LETTERS,
               type = "letter",
               shape = sample(c("circle", "rectangle"),
                              length(LETTERS),
                              replace = TRUE),
               fillcolor = sample(c("aqua", "gray80",
                                    "pink", "lightgreen",
                                    "azure", "yellow"),
                                  length(LETTERS),
                                  replace = TRUE))

edges &lt;-
  create_edges(from = sample(LETTERS, replace = TRUE),
               to = sample(LETTERS, replace = TRUE),
               rel = "letter_to_letter")

# Use the magrittr %>% operator between 'create_graph',
# and 'render_graph' or 'display_graph_object' calls
create_graph(nodes_df = nodes,
             edges_df = edges,
             graph_attrs = "layout = neato",
             node_attrs = c("fontname = Helvetica",
                            "style = filled"),
             edge_attrs = c("color = gray20",
                            "arrowsize = 0.5")) %>%
  render_graph

create_graph(nodes_df = nodes,
             edges_df = edges,
             graph_attrs = "layout = neato",
             node_attrs = c("fontname = Helvetica",
                            "style = filled"),
             edge_attrs = c("color = gray20",
                            "arrowsize = 0.5")) %>%
  display_graph_object

# Use the %>% operator between 'create_graph',
# 'render_graph', and 'cat' calls; the 'dot.gv' can be
# directly opened in Rstudio and further edited
create_graph(nodes_df = nodes,
             edges_df = edges,
             graph_attrs = "layout = neato",
             node_attrs = c("fontname = Helvetica",
                            "style = filled"),
             edge_attrs = c("color = gray20",
                            "arrowsize = 0.5")) %>%
  render_graph(output = "DOT") %>% cat(file = "~/dot.gv")</code></pre>
                        </div>
                    </div>
                    <h2 id="inspecting-the-graph">Inspecting the Graph</h2>
                    <p>Knowing what's in the graph is important. Several functions allow you to get information about the current state of the graph object. You can get very general information about the graph's node or edges, or, more specific information such as the predecessors and successors for a certain node in the graph</p>
                    <p>There are 12 functions that can be used to inspect graphs:</p>
                    <ul>
                            <li><code>node_info()</code> <em>Get detailed information on nodes</em></li>
                            <li><code>edge_info()</code> <em>Get detailed information on edges</em></li>
                            <li><code>node_present()</code> <em>Determine whether a specified node is present in an existing graph object</em></li>
                            <li><code>edge_present()</code> <em>Determine whether a specified edge is present in an existing graph object</em></li>
                            <li><code>get_nodes()</code> <em>Get vector of node IDs</em></li>
                            <li><code>get_edges()</code> <em>Get node IDs associated with edges</em></li>
                            <li><code>get_predecessors()</code> <em>Get node IDs for predecessor nodes to the specified node</em></li>
                            <li><code>get_successors()</code> <em>Get node IDs for successor nodes to the specified node</em></li>
                            <li><code>node_count()</code> <em>Get count of all nodes or certain types of nodes</em></li>
                            <li><code>edge_count()</code> <em>Get count of all edges or edges with distinct relationship types</em></li>
                            <li><code>is_graph_empty()</code> <em>Is the graph empty?</em></li>
                            <li><code>is_graph_directed()</code> <em>Is the graph a directed graph?</em></li>
                    </ul>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/node_info_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/edge_info_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/node_present_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/edge_present_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/get_nodes_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/get_edges_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/get_predecessors_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/get_successors_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/node_count_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/edge_count_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/is_graph_empty_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/is_graph_directed_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>

                    <p>The <code>node_info()</code> and <code>edge_info()</code> functions provide information about the nodes and edges in the graph. The information is presented in the form of a data frame. For <code>node_info()</code>, the following data is returned:</p>
                        <ul>
                            <li><code>node</code></li>
                            <li><code>label</code></li>
                            <li><code>type</code></li>
                            <li><code>degree</code></li>
                            <li><code>indegree</code></li>
                            <li><code>outdegree</code></li>
                            <li><code>loops</code></li>
                        </ul>
                    <p>From the <code>edge_info()</code> function, the resultant data frame has the following columns:</p>
                        <ul>
                            <li><code>from</code></li>
                            <li><code>to</code></li>
                            <li><code>rel</code></li>
                            <li><code>label</code></li>
                        </ul>
                    <p>The <code>node_present()</code> and <code>edge_present()</code> functions are used to determine whether a node (based on its node ID) or an edge (based on two node IDs) is present in a graph object. Both functions return a logical value of either <code>TRUE</code> or <code>FALSE</code>.</p>
                    <p>The purpose of the <code>get_nodes()</code> and <code>get_edges()</code> functions is to return either all of the nodes or edges (i.e., pairs of nodes, ordered by direction) available in the graph, or, in data frames for nodes or edges. For <code>get_nodes()</code>, one can simply supply either a graph object, a data frame for nodes, or a data frame for edges, and a vector of node IDs will be returned. For the <code>get_edges()</code> function, there is an additional argument called <code>return_type</code>, where you can specify three different types of return objects: a list with <code>return_type = list</code>, a data frame with <code>return_type = df</code>, and a character vector with <code>return_type = vector</code>. Whereas <code>get_nodes()</code> works with graph objects and data frames for nodes and edges, <code>get_edges()</code> works only with graph objects and node data frames.</p>
                    <p>The <code>get_predecessors()</code> and <code>get_successors()</code> function take both a graph object and a specified node in that graph and determine which nodes are its predecessors or successors, respectively.</p>
                    <p>To get a count of all or certain types of nodes available in the graph, you can use the <code>node_count()</code> function. The argument <code>type</code> can either be supplied with a <code>TRUE</code> or <code>FALSE</code> value, or, a character vector containing the values for the node type which may be available for nodes in the graph. Providing <code>TRUE</code> will issue a named vector of node counts by their type. Any nodes with a <code>type</code> attribute not set with a value are placed into a separate count category. Using <code>type = FALSE</code> with <code>node_count()</code> simply supplies a single-value vector with a total count of nodes in the graph. By providing a vector of character values of available node <code>type</code> values, a numerical named vector of counts for only those specified types will be returned.</p>
                    <p>The <code>is_graph_empty()</code> and <code>is_graph_directed()</code> functions simply return either <code>TRUE</code> or <code>FALSE</code> for whether the graph is empty or whether the graph is a directed graph. These are likely to be most useful in verification statement for scripts that add and remove nodes from the graph, or, those scripts that may toggle the graph between directed and undirected states.</p>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint">###
# Create a graph
###

library(DiagrammeR)

set.seed(26)

# Create a node data frame
nodes &lt;-
  create_nodes(nodes = LETTERS,
               label = TRUE,
               type = c(rep("a_to_g", 7),
                        rep("h_to_p", 9),
                        rep("q_to_x", 8),
                        rep("y_and_z",2)))

# Create an edge data frame
edges &lt;-
  create_edges(from = sample(LETTERS, replace = TRUE),
               to = sample(LETTERS, replace = TRUE),
               label = "edge",
               rel = "letter_to_letter")

# Create a graph object
graph &lt;-
  create_graph(nodes_df = nodes,
               edges_df = edges,
               graph_attrs = "layout = neato",
               node_attrs = c("fontname = Helvetica",
                              "shape = circle"))

###
# Is the graph empty?
###

# Use the 'is_graph_empty' function to return a logical value
is_graph_empty(graph)
#> FALSE

###
# Get basic information on the graph's nodes and edges
###

# Use the 'node_info' function to return a data frame
node_info(graph)
#>    node_ID label    type degree indegree outdegree loops
#> 1        A     A  a_to_g      2        0         2     0
#> 2        W     W  q_to_x      1        0         1     0
#> 3        T     T  q_to_x      2        0         2     0
#> 4        L     L  h_to_p      1        0         1     0
#> 5        F     F  a_to_g      0        0         0     0
#>..      ...   ...     ...    ...      ...       ...   ...

# Use the 'edge_info' function to return a data frame
edge_info(graph)
#>    from  to     rel label
#> 1     A   Z letter_to_letter  edge
#> 2     H   U letter_to_letter  edge
#> 3     W   O letter_to_letter  edge
#> 4     U   K letter_to_letter  edge
#> 5     I   V letter_to_letter  edge
#>..   ... ...              ...   ...

###
# Find out if a node is present in the graph
###

# Verify that node with ID 'a' is not in graph
# with the 'node_present' function
node_present(graph, "a")
#> FALSE

# Is node with ID 'A' in the graph?
node_present(graph, "A")
#> TRUE

# Are all node ID values from the LETTERS vector in the graph?
all(sapply(LETTERS, function(x) node_present(graph, x)))
#> TRUE

###
# Find out if an edge is present in the graph
###

# Is there any edge between nodes with IDs 'A' and 'B'?
# Use the 'edge_present' function to find out
edge_present(graph, from = "A", to = "B")
#> FALSE

# Verify that there is an edge between nodes 'K' and 'V'
edge_present(graph, from = "K", to = "V")
#> TRUE

###
# Get vector of all nodes in a graph, or in data frames
# for nodes or edges
###

# Use the 'get_nodes' function to return node ID values
get_nodes(graph)
#> [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L"
#> [13] "M" "N" "O" "P" "Q" "R" "S" "T" "U" "V" "W" "X"
#> [25] "Y" "Z"

# Can extract a vector of node ID values from a data frame
# for nodes
table(get_nodes(nodes) %in% get_nodes(graph))
#>
#> TRUE
#>   26

# Can also extract a vector of node ID values from a
# data frame for edges
table(get_nodes(graph) %in% get_nodes(edges))
#>
#> FALSE  TRUE
#>     3    23

###
# Get object with all edges in a graph, or in a data
# frame for edges
###

# Can get the 'outgoing' and 'incoming' node ID values
# in a list object
get_edges(graph, return_type = "list") # the default
#> [[1]]
#>  [1] "A" "H" "W" "U" "I" "M" "U" "T" "I" "R" "O"
#> [12] "G" "O" "A" "V" "I" "M" "K" "R" "T" "Y" "R"
#> [23] "M" "L" "H" "V"

#> [[2]]
#>  [1] "Z" "U" "O" "K" "V" "M" "N" "C" "D" "Z" "B"
#> [12] "G" "U" "Y" "H" "V" "R" "V" "Z" "S" "Q" "I"
#> [23] "P" "S" "E" "P"

# Similarly, you can specify that a data frame is given
get_edges(graph, return_type = "df")
#>    from to
#> 1     A  Z
#> 2     H  U
#> 3     W  O
#> 4     U  K
#> 5     I  V
#>..   ... ..

# A character string with node IDs can also be obtained
get_edges(graph, return_type = "vector")
#>  [1] "A -&gt; Z" "H -&gt; U" "W -&gt; O" "U -&gt; K" "I -&gt; V"
#>  [6] "M -&gt; M" "U -&gt; N" "T -&gt; C" "I -&gt; D" "R -&gt; Z"
#> [11] "O -&gt; B" "G -&gt; G" "O -&gt; U" "A -&gt; Y" "V -&gt; H"
#> [16] "I -&gt; V" "M -&gt; R" "K -&gt; V" "R -&gt; Z" "T -&gt; S"
#> [21] "Y -&gt; Q" "R -&gt; I" "M -&gt; P" "L -&gt; S" "H -&gt; E"
#> [26] "V -&gt; P"

###
# As with 'get_nodes', the 'get_edges' function works
# in an analogous manner with data frames for edges
###

all(get_edges(edges, return_type = "list")[[1]] ==
      get_edges(graph, return_type = "list")[[1]])
#> TRUE

all(get_edges(edges, return_type = "df") ==
      get_edges(graph, return_type = "df"))
#> TRUE

all(get_edges(edges, return_type = "vector") ==
      get_edges(graph, return_type = "vector"))
#> TRUE

###
# Get all the predecessors or all of the successors
# of a given node
###

# If there are no predecessors, NA is returned
get_predecessors(graph, node = "A")
#> [1] NA

get_successors(graph, node = "A")
#> [1] "Z" "Y"

get_successors(graph, node = "Z")
#> [1] NA

get_predecessors(graph, node = "Z")
#> [1] "A" "R" "R"

# Find isolated nodes in a graph (they have neither successors
# nor predecessors)
intersect(
  names(which(is.na(sapply(get_nodes(graph),
                           function(x) get_successors(graph, x))))),
  names(which(is.na(sapply(get_nodes(graph),
                           function(x) get_predecessors(graph, x)))))
)
#> [1] "F" "J" "X"

# The isolated nodes can also be found by subsetting 'node_info'
node_info(graph)[which(node_info(graph)["degree"] == 0), ][, 1]
#> [1] "F" "J" "X"

###
# Get a count of all nodes in a graph
###

# Get counts of nodes grouped by the 'type' attribute
node_count(graph, type = TRUE) # the default
#> a_to_g  h_to_p  q_to_x y_and_z
#>      7       9       8       2

# Get a total count of nodes with no grouping
node_count(graph, type = FALSE)
#> [1] 26</code></pre>
                        </div>
                    </div>
                    <h2 id="modifying-the-graph">Modifying the Graph</h2>
                    <p>Add nodes, delete edges, modify relationships between nodes, and set node type declarations. Those are some of the things you can do with these graph construction/destruction functions.</p>
                    <p>There are 6 functions with which one can modify graphs:</p>
                    <ul>
                            <li><code>add_node()</code> <em>Add a node to an existing graph object</em></li>
                            <li><code>add_edge()</code> <em>Add edges to an existing graph object</em></li>
                            <li><code>delete_node()</code> <em>Delete a node from an existing graph object</em></li>
                            <li><code>delete_edge()</code> <em>Delete an edge from an existing graph object</em></li>
                            <li><code>node_type()</code> <em>Create, read, update, delete, or report status of a node type definition</em></li>
                            <li><code>edge_rel()</code> <em>Create, read, update, delete, or report status of an edge relationship</em></li>
                    </ul>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/add_node_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/add_edge_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/delete_node_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/delete_edge_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/node_type_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/edge_rel_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                    <p>The <code>add_node()</code> function allows one to add a single node to a graph. Specify the graph to which the node should be added and the node ID for the <code>node</code> argument, and a node will be added. While the other arguments are optional, using just <code>graph</code> and <code>node</code> will result in the addition of an unconnected node. This might be desirable (say, if the graph is empty), but the more likely case is that edges to other nodes will be required upon addition of a new node. The <code>from</code> and <code>to</code> arguments (both optional) are where you would specify connections from existing nodes to the new node (with <code>to</code>), and connections to existing nodes from the new node (with <code>from</code>). A vector of node IDs can be supplied to either argument. The <code>label</code> and <code>type</code> arguments allow for direct setting of these node attributes during the addition of a node. Finally, a named vector of node attributes and their values can be included in the <code>add_node()</code> call.</p>
                    <p>The <code>add_edge()</code> function is meant for adding edges between extant graph nodes. Because the nodes must exist in the graph, this function cannot be invoked for an empty graph. (It can, however, be used for a graph with a single node since an edge can be created as a loop from and to the same node.) there are two means to add edges to a graph with this function:</p>
                    <ol>
                      <li>specify <code>from</code> and <code>to</code> nodes for the edge to be added; add an edge <code>rel</code> string as a value for the <code>rel</code> argument</li>
                      <li>supply a data frame for edges, which contains columns for incoming and outgoing nodes, and, various edge attributes</li>
                    </ol>
                    <p>It can be advantageous to supply a data frame for edges to this function's <code>edges_df</code> argument. This simply because one can supply a range of edge attributes for the new edge. On the other hand, providing only values to the <code>from</code>, <code>to</code>, and <code>rel</code> arguments may be sufficient, especially if styling if not required or handled through default edge attributes.</p>
                    <p>The function <code>delete_node()</code> removes a node from the graph. All of the removed node's edges with other nodes in the graph will also be removed in this operation. Supply only a single node ID to the <code>node</code> argument.</p>
                    <p>The function <code>delete_edge()</code> removes an edge from the graph. Specify the graph object in <code>graph</code>, the nodes in <code>nodes</code>, and the function will remove that edge if it exists.</p>
                    <p>The <code>node_type()</code> function provides various means to check the <code>type</code> attribute for a node and perform different operations on that attribute. The different functionalities of <code>node_type</code> can be changed through the use of these different keywords for the <code>action</code> argument: <code>read</code>, <code>check</code>, <code>add</code>, <code>update</code>, and <code>delete</code>. With <code>read</code> set as the action, a node ID supplied with the graph object yields that node's <code>type</code> attribute. Using <code>action = check</code> with a node ID, you can check whether a <code>type</code> attribute exists (it will return <code>TRUE</code> or <code>FALSE</code>. If the <code>type</code> attribute hasn't been set for a node, you can add that using <code>action = add</code> along with a string supplied for the <code>value</code> argument. If a <code>type</code> attribute has alredy been set for a node and you'd like to change it, use <code>action = update</code> and include the updated string with the <code>value</code> argument. Deleting a <code>type</code> attribute for a node is easily accomplished by using <code>action = delete</code>.</p>
                    <p>The <code>edge_rel()</code> function is similar in principle and use to the <code>node_type()</code> function. In this function, the edges' <code>rel</code> attribute can be checked for existence, added, removed, or updated. As with the <code>node_type()</code> function, this function uses the <code>action</code> argument and performs various actions with these keywords: <code>read</code>, <code>check</code>, <code>add</code>, <code>update</code>, and <code>delete</code> (same keywords as those for <code>node_type()</code>). Using <code>read</code>, supply node IDs for the <code>from</code> and <code>to</code> arguments. With that, you will receive the edge's currently set <code>rel</code> attribute. The <code>rel</code> attribute may or may not be set, so, using <code>action = check</code> with a specified edge, the existence of the <code>rel</code> attribute can be verified through a <code>TRUE</code> or <code>FALSE</code> return value. An unset <code>rel</code> attribute for an edge can be set by using <code>action = add</code> and a character string for the <code>value</code> argument. To update an already set <code>rel</code> attribute for an edge, use <code>action = update</code> and provide the updated relationship string with the <code>value</code> argument. Deleting a <code>rel</code> attribute for an edge is done by using <code>action = delete</code> with an edge.</p>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint">library(DiagrammeR)

# Create an empty graph
graph &lt;- create_graph()

# Add two nodes
graph &lt;- add_node(graph, node = "a")
graph &lt;- add_node(graph, node = "b")

# Get information on all nodes in graph
node_info(graph)
#>   node_ID label type degree indegree outdegree loops
#> 1       a     a   NA      0        0         0     0
#> 2       b     b   NA      0        0         0     0

# Add an edge
graph &lt;- add_edge(graph, from = "a", to = "b",
                     rel = "to_get")

# Get information on all edges in graph
edge_info(graph)
#>   edge_from edge_to    rel  label
#> 1         a       b to_get     NA

# Add two more nodes
graph &lt;- add_node(graph, node = "c")
graph &lt;- add_node(graph, node = "d")

# Get information on all nodes in graph
node_info(graph)
#>   node_ID label type degree indegree outdegree loops
#> 1       a     a   NA      1        0         1     0
#> 2       c     c   NA      0        0         0     0
#> 3       d     d   NA      0        0         0     0
#> 4       b     b   NA      1        1         0     0

# Add two more edges
graph &lt;-
  add_edge(graph,
           from = c("a", "a"),
           to = c("c", "d"),
           rel = "received_from")

# Get information on all edges in graph
edge_info(graph)
#>   edge_from edge_to           rel label
#> 1         a       b        to_get    NA
#> 2         a       c received_from    NA
#> 3         a       d received_from    NA

# Remove a node (removing a node removes its edges)
graph &lt;- delete_node(graph, node = "d")

# Get information on all nodes in graph
node_info(graph)
#>   node_ID label type degree indegree outdegree loops
#> 1       a     a   NA      2        0         2     0
#> 2       b     b   NA      1        1         0     0
#> 3       c     c   NA      1        1         0     0

# Remove an edge (removing an edge retains nodes)
graph &lt;- delete_edge(graph, from = "a", to = "c")

# Get information on all edges in graph
edge_info(graph)
#>   edge_from edge_to    rel label
#> 1         a       b to_get    NA</code></pre>
                        </div>
                    </div>
                    <h2 id="using-graph-series">Using a Series of Graphs</h2>
                    <p>There may be situations where multiple graphs are required for analysis. A convenient means to work with several graphs is with the graph series object, which serializes graph objects. The time and sequence properties of the contained graphs can be used for subsetting. Scripts can be triggered for the series that allow for things such as data collection and creation of multiple graphs within the series object.</p>
                    <p>There are 8 functions available for working with a graph series:</p>
                    <ul>
                            <li><code>create_series()</code> <em>Create a graph series object</em></li>
                            <li><code>add_to_series()</code> <em>Add graph object to a graph series object</em></li>
                            <li><code>remove_from_series()</code> <em>Remove graph object from a graph series object</em></li>
                            <li><code>graph_count()</code> <em>Count graphs in a graph series object</em></li>
                            <li><code>subset_series()</code> <em>Subset a graph series object</em></li>
                            <li><code>trigger_script()</code> <em>Trigger a script embedded in a graph series object</em></li>
                            <li><code>render_graph_from_series()</code> <em>Render a graph available in a series</em></li>
                            <li><code>series_info()</code> <em>Get detailed information on a graph series</em></li>
                    </ul>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/create_series_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/add_to_series_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/remove_from_series_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/graph_count_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/subset_series_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/trigger_script_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/render_graph_from_series_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/series_info_2x.png" class="img-responsive center-block">
                        </div>
                        <div>
                            <img src="img/graph-functions/spacer_2x.png" class="img-responsive center-block">
                        </div>
                <p>The following example demonstrates how to create a series object with an existing graph object using the <code>create_series()</code> and <code>add_to_series()</code> functions. Since we'd likely want to be able to remove graphs from a series, the <code>remove_from_series()</code> function will be used. The use of <code>count_graphs()</code> and <code>series_info()</code> allows us to get information about the graph series object: <code>count_graphs()</code> returns a simple count of graph objects are present in a graph series, and <code>series_info()</code> yields a data frame with basic information about each graph object present in the graph series.</p>
                <div class="highlight">
                        <div>
                            <pre><code class="prettyprint">#####
# Create and manipulate a graph series
#####

library(DiagrammeR)
library(pipeR)

# Create three different graphs
graph_1 &lt;- create_graph() %>%
  add_node("a") %>% add_node("b") %>% add_node("c") %>%
  add_edge(from = c("a", "a", "b"),
            to =   c("c", "b", "c"))

graph_2 &lt;- graph_1 %>%
  add_node("d") %>% add_edge(from = "d", to = "c")

graph_3 &lt;- graph_2 %>%
  add_node("e") %>% add_edge(from = "e", to = "b")

# Create an empty graph series
series &lt;- create_series(series_type = "sequential")

# Confirm that the series is empty
graph_count(series)
#> [1] 0

# Add graphs to the graph series
series &lt;- graph_1 %>% add_to_series(series)
series &lt;- graph_2 %>% add_to_series(series)
series &lt;- graph_3 %>% add_to_series(series)

# Count the number of graphs in the series
graph_count(series)
#> [1] 3

# Get information on the graphs in the series
series_info(series)
#>   graph name date_time   tz nodes edges directed
#> 1     1 &lt;NA>      &lt;NA> &lt;NA>     3     3     TRUE
#> 2     2 &lt;NA>      &lt;NA> &lt;NA>     4     4     TRUE
#> 3     3 &lt;NA>      &lt;NA> &lt;NA>     5     5     TRUE

# Remove 2 graphs from graph series
series &lt;- remove_from_series(graph_series = series, index = 2)
series &lt;- remove_from_series(graph_series = series, index = "last")

# Count the number of graphs in the series
graph_count(series)
#> [1] 1</code></pre>
                        </div>
                    </div>
                    <p>With the <code>subset_series()</code> function you can create a graph series object that contains a subset of graphs. This is useful if you collect and process data into temporal graphs and you'd like to conduct an analysis over some time frame (e.g., graphs generated from collected data on weekdays vs. those graphs using data on weekend days). The <code>subset_series()</code> function works well with both <code>sequential</code> and <code>temporal</code> graph series types.</p>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint">#####
# Subset a graph series by time and by sequence
#####

library("DiagrammeR")
library("pipeR")

# Create two graphs with the time attributes set
graph_time_1 &lt;-
  create_graph(graph_name = "graph_with_time_1",
               graph_time = "2015-03-25 03:00",
               graph_tz = "GMT") %>%
  add_node("a") %>% add_node("b") %>% add_node("c") %>%
  add_edge(from = c("a", "a", "b"),
           to =   c("c", "b", "c"))

graph_time_2 &lt;-
  create_graph(graph_name = "graph_with_time_2",
               graph_time = "2015-03-26 03:00",
               graph_tz = "GMT") %>%
  add_node("d") %>% add_node("e") %>% add_node("f") %>%
  add_edge(from = c("d", "d", "e"),
           to =   c("f", "e", "f"))

graph_time_3 &lt;-
  create_graph(graph_name = "graph_with_time_3",
               graph_time = "2015-03-27 15:00",
               graph_tz = "GMT") %>%
  add_node("x") %>% add_node("y") %>% add_node("z") %>%
  add_edge(from = c("x", "x", "y"),
           to =   c("z", "y", "z"))


# Create an empty graph series
series_temporal &lt;- create_series(series_type = "temporal")

# Add graphs to the graph series
series_temporal &lt;- graph_time_1 %>% add_to_series(series_temporal)
series_temporal &lt;- graph_time_2 %>% add_to_series(series_temporal)
series_temporal &lt;- graph_time_3 %>% add_to_series(series_temporal)

# Subset graph series by sequence
series_sequence_subset &lt;-
  subset_series(graph_series = series_temporal,
                by = "number",
                values = 2)

graph_count(series_sequence_subset)
#> [1] 1

# Subset graph series by date-time
series_time_subset &lt;-
  subset_series(graph_series = series_temporal,
                by = "time",
                values = c("2015-03-25 12:00",
                           "2015-03-26 12:00"),
                tz = "GMT")

graph_count(series_time_subset)
#> [1] 1</code></pre>
                        </div>
                    </div>
                    <p>Because data collection and using rules to determine how the graph should be generated can be scripted, it makes sense to have those scripts close at hand and also to have the ability to periodically trigger those scripts. For this use case, the <code>trigger_script()</code> function will prove useful. It simply runs a script contained in a graph series object, and, returns a modified graph series object. In the following example, a script is directly added to graph series object as a character vector. There is the option to instead use a reference to an **R** script on disk. This is done by supplying a path to the file (including the file name) in the <code>series_scripts</code> argument when calling the <code>create_series()</code> function.</p>
                    <p>In the following example, a script essentially takes an empty graph series and builds up a random graph, adding a new node and edges with each triggering of the script. On new days, the script will create a new graph and build that graph. Throughout the script, <code>_SELF_</code> refers to the graph series in which the script is contained.</p>
                    <div class="bs-example">
                        <img src="img/graph-functions/script_trigger_example.png" class="img-responsive center-block">
                    </div>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint">#####
# Trigger a script and render select graphs from a graph series
#####

library("DiagrammeR")

sample_node_script &lt;-
'
graph_attrs &lt;- c("layout = twopi",
                 "overlap = FALSE",
                 "outputorder = edgesfirst")

node_attrs &lt;- c("shape = circle",
                "fixedsize = TRUE",
                "width = 1",
                "penwidth = 1",
                "color = DodgerBlue",
                "style = filled",
                "fillcolor = Aqua",
                "alpha_fillcolor = 0.5",
                "fontname = Helvetica",
                "fontcolor = Grey25")

edge_attrs &lt;- c("arrowhead = dot",
                "minlen = 1.5",
                "color = Green",
                "penwidth = 2")

# If there is no graph available in the series, then, make one!
if (graph_count(graph_series = _SELF_) == 0){

  _SELF_ &lt;-
    add_to_series(graph = create_graph(graph_attrs = graph_attrs,
                                       node_attrs = node_attrs,
                                       edge_attrs = edge_attrs,
                                       graph_name = paste0("data_", Sys.Date()),
                                       graph_time = as.character(Sys.Date()),
                                       graph_tz = Sys.timezone()),
                  graph_series = _SELF_)

}

# Determine the index of the last graph in the series
last_graph_in_series &lt;- graph_count(graph_series = _SELF_)

# If it is a new day, create a new graph in the series to populate with data
if (Sys.Date() > as.Date(_SELF_$graphs[[last_graph_in_series]]$graph_time,
                          tz = _SELF_$graphs[[last_graph_in_series]]$graph_tz)){

  _SELF_ &lt;-
    add_to_series(graph = create_graph(graph_attrs = graph_attrs,
                                       node_attrs = node_attrs,
                                       edge_attrs = edge_attrs,
                                       graph_name = paste0("data_", Sys.Date()),
                                       graph_time = as.character(Sys.Date()),
                                       graph_tz = Sys.timezone()),
                  graph_series = _SELF_)

  last_graph_in_series &lt;- graph_count(graph_series = _SELF_)
}

# Create a node to place into the graph
letters &lt;- paste(sample(LETTERS, 5), collapse = "")

# Add node to the most recent graph and attach it to
# another randomly picked node available in the graph.
# Note that adding an edge only works in the case that
# there is at least one node available in the graph.
# For convenience, the relevant graph is extracted from
# the series, then placed back in the series.
if (!is.na(sample(get_nodes(_SELF_$graphs[[last_graph_in_series]]), 1))){

  graph &lt;- _SELF_$graphs[[last_graph_in_series]]

  graph &lt;- add_node(graph = graph,
                    node = letters)

  graph &lt;- add_edge(graph = graph,
                       from = letters,
                       to = sample(get_nodes(graph = graph), 1))

} else {

  graph &lt;- _SELF_$graphs[[last_graph_in_series]]

  graph &lt;- add_node(graph = graph,
                   node = letters)
}

# Remove old graph from series
_SELF_ &lt;- remove_from_series(graph_series = _SELF_,
                             index = "last")

# Add new graph to correct position in series
# The "add_to_series" function always adds a graph to the
# end of the graph series.
_SELF_ &lt;- add_to_series(graph = graph,
                        graph_series = _SELF_)

return(_SELF_)
'

# Create an empty graph series of the 'temporal' type and add
# that script as one of the graph series' 'series scripts'
series_temporal &lt;- create_series(series_type = "temporal",
                                 series_scripts = sample_node_script)

# Call the function 60 times, this will generate 60 random nodes
# with 59 edges
for (i in seq(1, 60)){

  series_temporal &lt;-
    trigger_script(graph_series = series_temporal,
                   script = 1)

  if (i == 60) break
}

# Display the results in the RStudio Viewer
render_graph_from_series(graph_series = series_temporal,
                         graph_no = graph_count(series_temporal))

# Get some basic information about the graphs in the graph series object
series_info(series_temporal)

# Write the script to a file
cat(sample_node_script, file = "~/Desktop/sample_node_script.R")

# Create a reference to the file instead of including text directly
# in the "series_temporal" object
series_temporal &lt;-
  create_series(series_type = "temporal",
                series_scripts = "~/Desktop/sample_node_script.R")

# Call the function 60 times, this will generate 60 random nodes
# with 59 edges
for (i in seq(1, 60)){

  series_temporal &lt;-
    trigger_script(graph_series = series_temporal,
                   script = 1)

  if (i == 60) break
}

# Display the results in the RStudio Viewer
render_graph_from_series(graph_series = series_temporal,
                         graph_no = graph_count(series_temporal)</code></pre>
                        </div>
                    </div>
                </div>
                <div class="bs-docs-section">
                    <h1 id="examples" class="page-header">Examples</h1>
                    <p class="lead">Here is an example for demonstrating how these graph functions can be used with external datasets.</p>
                    <h2 id="nycflights13">Data from nycflights13</h2>
                    <p>Let's use the <strong>nycflights13</strong> package to prepare some data frames and then create a graph diagram.</p>
                    <div class="bs-example">
                        <img src="img/grviz_example-3-1.png" class="img-responsive center-block">
                    </div>
                    <div class="highlight">
                        <div>
                            <pre><code class="prettyprint"># Get the 'nycflights13' package if not already installed
# install.packages('nycflights13')

# Get the 'lubridate' package if not already installed
# install.packages('lubridate')

# Get the latest build of the 'DiagrammeR' package from GitHub
devtools::install_github('rich-iannone/DiagrammeR')

library(nycflights13)
library(lubridate)
library(DiagrammeR)

# Choose a day from 2013 for NYC flight data
# (You can choose any Julian day, it's interesting to see results for different days)
day_of_year &lt;- 10

# Get a data frame of complete cases (e.g., flights have departure and arrival times)
nycflights13 &lt;-
  nycflights13::flights[which(complete.cases(nycflights13::flights) == TRUE), ]

# Generate a POSIXct vector of dates using the 'ISOdatetime' function
# Columns 1, 2, and 3 are year, month, and day columns
# Column 4 is a 4-digit combination of hours (00-23) and minutes (00-59)
date_time &lt;-
  data.frame("date_time" =
               ISOdatetime(year = nycflights13[,1],
                           month = nycflights13[,2],
                           day = nycflights13[,3],
                           hour = gsub("[0-9][0-9]$", "", nycflights13[,4]),
                           min = gsub(".*([0-9][0-9])$", "\\1", nycflights13[,4]),
                           sec = 0, tz = "GMT"))

# Add the POSIXct vector 'date_time' to the 'nycflights13' data frame
nycflights13 &lt;- cbind(date_time, nycflights13)

# Select flights only from the specified day of the year 2013
nycflights13_day &lt;-
  subset(nycflights13,
         date_time >= ymd('2013-01-01', tz = "GMT") + days(day_of_year - 1) &
           date_time &lt; ymd('2013-01-01', tz = "GMT") + days(day_of_year))

# Create the 'nodes' data frame where at least one column is named "nodes" or "node_id"
# Column 12 is the 3-letter code for the airport departing from
# Column 13 is for the airport arriving to
# (Option: change df to 'nycflights13_day' and only airports used for the day will be included)
nodes_df &lt;-
   create_nodes(nodes = unique(c(nycflights13[,12],
                                 nycflights13[,13])),
                label = FALSE)

# The 'edges' data frame must have columns named 'from' and 'to'
# The color attribute is determined with an 'ifelse' statement, where
# column 8 is the minutes early (negative values) or minutes late (positive values)
# for the flight arrival
edges_df &lt;-
   create_edges(from = nycflights13_day[,12],
                to = nycflights13_day[,13],
                color = ifelse(nycflights13_day[,8] &lt; 0,
                               "green", "red"))

# Set the graph diagram's default attributes for...

# ...nodes
node_attrs &lt;- c("style = filled",
                "fillcolor = lightblue",
                "color = gray",
                "shape = circle",
                "fontname = Helvetica",
                "width = 1")

# ...edges
edge_attrs &lt;- c("arrowhead = dot")

# ...and the graph itself
graph_attrs &lt;- c("layout = circo",
                 "overlap = false",
                 "fixedsize = true",
                 "ranksep = 3",
                 "outputorder = edgesfirst")

# Generate the graph diagram and render in the RStudio Viewer.
# The green lines show flights that weren't late (red indicates late arrivals).
# This graph is for a single day of flights, airports that are unconnected on a
# given day may be destinations on another day
create_graph(nodes_df = nodes_df, edges_df = edges_df,
             graph_attrs = graph_attrs, node_attrs = node_attrs,
             edge_attrs = edge_attrs, directed = TRUE) %>%
               render_graph(width = 1200, height = 800)</code></pre>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-md-3" role="complementary">
                <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm">
                    <ul class="nav bs-docs-sidenav">
                        <li>
                            <a href="#building-graphs">Building Graphs</a>
                            <ul class="nav">
                                <li><a href="#the-graph-functions">The Graph Functions</a></li>
                                <li><a href="#the-graph-object">The Graph Object</a></li>
                                <li><a href="#specialized-data-frames">Specialized Data Frames</a></li>
                            </ul>
                        </li>
                        <li>
                            <a href="#graph-functions">Graph Functions</a>
                            <ul class="nav">
                                <li><a href="#node-edge-data-frames">Node/Edge Data Frames</a></li>
                                <li><a href="#create-render-graph">Create and Render Graph</a></li>
                                <li><a href="#inspecting-the-graph">Inspecting the Graph</a></li>
                                <li><a href="#modifying-the-graph">Modifying the Graph</a></li>
                                <li><a href="#using-graph-series">Using a Series of Graphs</a></li>
                            </ul>
                        </li>
                        <li>
                            <a href="#examples">Examples</a>
                            <ul class="nav">
                                <li><a href="#nycflights13">Data from nycflights13</a></li>
                            </ul>
                        </li>
                    </ul>
                    <a class="back-to-top" href="#top">Back to top</a>
                </nav>
            </div>
        </div>
        <footer class="bs-docs-footer" role="contentinfo">
            <div class="container">
                <div class="bs-docs-social">
                    <ul class="bs-docs-social-buttons">
                        <li>
                            <iframe class="github-btn" src="http://ghbtns.com/github-btn.html?user=rich-iannone&amp;repo=DiagrammeR&amp;type=watch&amp;count=true" width="90" height="20" title="Star on GitHub"></iframe>
                        </li>
                        <li>
                            <iframe class="github-btn" src="http://ghbtns.com/github-btn.html?user=rich-iannone&amp;repo=DiagrammeR&amp;type=fork&amp;count=true" width="90" height="20" title="Fork on GitHub"></iframe>
                        </li>
                    </ul>
                    <ul class="bs-docs-social-buttons">
                        <li class="follow-btn">
                            <a href="https://twitter.com/riannone" class="twitter-follow-button" data-link-color="#0069D6" data-show-count="true">Follow @riannone</a>
                        </li>
                    </ul>
                </div>
            </div>
            <div class="container">
                <p>Designed and built by Richard Iannone <a href="https://twitter.com/riannone" target="_blank">@riannone</a>.</p>
                <p>Valuable contributions by Kent Russell <a href="https://twitter.com/timelyportfolio" target="_blank">@timelyportfolio</a>, JJ Allaire <a href="https://twitter.com/rstudio" target="_blank">@rstudio</a>, and Michal Benesty <a href="https://twitter.com/pommedeterre33" target="_blank">@pommedeterre33</a>.</p>
                <p>Code licensed under MIT.</p>
                <ul class="bs-docs-footer-links text-muted">
                    <li>Currently v0.8.1</li>
                    <li>&middot;</li>
                    <li><a href="https://github.com/rich-iannone/DiagrammeR">GitHub</a></li>
                    <li>&middot;</li>
                    <li><a href="https://github.com/rich-iannone/DiagrammeR/issues">Issues</a></li>
                    <li>&middot;</li>
                    <li><a href="https://github.com/rich-iannone/DiagrammeR/releases">Releases</a></li>
                </ul>
            </div>
        </footer>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.2/jquery.min.js"></script>
        <script src="./js/bootstrap.min.js"></script>
        <script src="./js/docs.min.js"></script>
        <script src="./js/ie10-viewport-bug-workaround.js"></script>
        <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>

        <script>
          window.twttr = (function (d,s,id) {
            var t, js, fjs = d.getElementsByTagName(s)[0];
            if (d.getElementById(id)) return; js=d.createElement(s); js.id=id; js.async=1;
            js.src="https://platform.twitter.com/widgets.js"; fjs.parentNode.insertBefore(js, fjs);
            return window.twttr || (t = { _e: [], ready: function(f){ t._e.push(f) } });
          }(document, "script", "twitter-wjs"));
        </script>

    </body>
</html>
